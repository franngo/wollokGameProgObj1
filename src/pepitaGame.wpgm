import wollok.game.*
import pepita.*
import posiciones.*
import extras.*
import randomizer.*
import paleta.*

program pepitaGame {
	game.title("Pepita Strikes Back") 	//Valor por defecto "Wollok Game"
	game.height(10) 		//valor por defecto 5
	game.width(10) 			//valor por defecto 5
	game.cellSize(50) 		//valor por defecto 50 (pero es preferible 64)
	//search assets in assets folder, for example, for the background
	game.boardGround("fondoPlaya1small.jpeg") //en vez de usar ground, que determina una imagen para TODAS las celdas, usamos boardGround, 
								   //que determina una imagen para todo el tablero
	game.addVisual(pepita)
	game.addVisual(listaDeObjetos)
	var arma1= new Arma() //crea 1 arma con atributos random en posicion random ni bien empiece el juego
	game.addVisual(arma1) //se importa el image() de su clase, o sea, Arma
						  //con game.removeVisual(arma1) lo sacamos. Cuando no tiene el visual, es como si no estuviera. el pj no puede
						  //interactuar con el objeto que no tiene visual.

	//debug
	game.showAttributes(pepita)
	game.showAttributes(arma1)

	//MOVIMIENTO

	//keyboard.w().whilePressRepeat({pepita.mover(arriba)},200) aparentemente
	//no funciona. Asumo que no lo migraron desde la vieja versión de wollok.

	//keyboard.w().whenKeyPressedDo({pepita.mover(arriba)}) esto es un
	//renombre de onPressDo()

	//antiguo movimiento
	//keyboard.w().onPressDo({pepita.mover(arriba)})
	//keyboard.d().onPressDo({pepita.mover(derecha)})
	//keyboard.s().onPressDo({pepita.mover(abajo)})
	//keyboard.a().onPressDo({pepita.mover(izquierda)})

	keyboard.w().onPressDo({
		if(!pepita.isMoving()) { //si pepita está quieta
			game.onTick(500, "pepitaMoving", {pepita.mover(arriba)})
			pepita.isMoving(true)
		} else { //si pepita se está moviendo
			game.removeTickEvent("pepitaMoving")
			pepita.isMoving(false)
		} 
	})
	keyboard.d().onPressDo({
		if(!pepita.isMoving()) { //si pepita está quieta
			game.onTick(500, "pepitaMoving", {pepita.mover(derecha)})
			pepita.isMoving(true)
		} else { //si pepita se está moviendo
			game.removeTickEvent("pepitaMoving")
			pepita.isMoving(false)
		} 
	})
	keyboard.s().onPressDo({
		if(!pepita.isMoving()) { //si pepita está quieta
			game.onTick(500, "pepitaMoving", {pepita.mover(abajo)})
			pepita.isMoving(true)
		} else { //si pepita se está moviendo
			game.removeTickEvent("pepitaMoving")
			pepita.isMoving(false) 
		} 
	})
	keyboard.a().onPressDo({
		if(!pepita.isMoving()) { //si pepita está quieta
			game.onTick(500, "pepitaMoving", {pepita.mover(izquierda)})
			pepita.isMoving(true)
		} else { //si pepita se está moviendo
			game.removeTickEvent("pepitaMoving")
			pepita.isMoving(false) 
		} 
	})

	//ACCIONES APARTE DEL MOVIMIENTO

	keyboard.k().onPressDo({pepita.atacar()}) //pepita ataca con su primer arma de la bolsa, que vendría a ser la actual

	//COLISIÓN

	//el parámetro del bloque (en este caso, arma), es el objeto con el que colisiona pepita. si hay más de uno, supongo que se ejecutaría
	//este mismo código tantas veces como objetos haya ahí
    game.onCollideDo(pepita, { arma => pepita.equiparArma(arma) game.say(pepita, "Agarre un arma, Oh Yeah!")} ) //mismo q whenCollideDo, no?

	//EVENTOS
	
	game.start()
}